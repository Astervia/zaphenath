{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Zaphenath Documentation","text":"<p>Zaphenath is a smart contract system for storing confidential data that becomes accessible after a period of user inactivity. It is ideal for digital wills, emergency business data access, and contingency disclosures.</p> <p>This documentation will guide you through everything you need to understand, deploy, and use the Zaphenath contract system.</p>"},{"location":"#what-is-zaphenath","title":"\ud83d\udd10 What is Zaphenath?","text":"<p>Zaphenath allows users to:</p> <ul> <li>Create encrypted data entries (\"keys\") that only they can access</li> <li>Configure access policies based on inactivity timeouts</li> <li>Delegate access and responsibilities to trusted custodians</li> <li>Toggle whether the data is readable before the timeout or only after</li> </ul> <p>It uses Solidity, is designed for Ethereum-compatible networks, and is built using the Foundry development stack.</p>"},{"location":"#documentation-sections","title":"\ud83d\udcda Documentation Sections","text":"<ul> <li>Getting Started: How to install and deploy Zaphenath</li> <li>Contracts: Source-level breakdown of each component</li> <li>Usage: Learn how to interact with the system securely</li> <li>Testing: Understand how the test suite validates behavior</li> <li>Support: Frequently asked questions and help resources</li> </ul>"},{"location":"#tech-stack","title":"\ud83d\udee0 Tech Stack","text":"<ul> <li>Solidity <code>^0.8.20</code></li> <li>Foundry (Forge + Anvil)</li> <li>Ethereum-compatible networks (e.g. Anvil, Sepolia)</li> </ul> <p>\u27a1\ufe0f Get started with the Overview</p>"},{"location":"business-whitepaper/","title":"\ud83e\uddfe Zaphenath Business White Paper","text":""},{"location":"business-whitepaper/#what-is-zaphenath","title":"What is Zaphenath?","text":"<p>Zaphenath is a smart contract protocol that protects sensitive information until a period of user inactivity has passed. Designed for Ethereum-compatible blockchains, Zaphenath lets users store encrypted data (a \"key\") and define exactly when and under what conditions it should become accessible to others.</p> <p>It's a solution built for wills, emergency data access, legal disclosure, and organizational continuity. If the original user becomes inactive\u2014measured by the absence of periodic \"pings\"\u2014data can be automatically released to trusted parties.</p>"},{"location":"business-whitepaper/#problem-opportunity","title":"Problem &amp; Opportunity","text":""},{"location":"business-whitepaper/#current-systems-fail","title":"\u274c Current Systems Fail","text":"<ul> <li>Cloud storage doesn\u2019t know if the user is alive or not.</li> <li>Legal will execution is slow, bureaucratic, and fallible.</li> <li>No blockchain-native solution exists to unlock encrypted content conditionally.</li> </ul>"},{"location":"business-whitepaper/#what-users-need","title":"\u2705 What Users Need","text":"<ul> <li>A verifiable liveness protocol.</li> <li>Fine-grained control over access and delegation.</li> <li>Something simple, secure, and non-custodial.</li> </ul> <p>Zaphenath is the first programmable solution to combine these elements in a decentralized way.</p>"},{"location":"business-whitepaper/#how-it-works","title":"How It Works","text":"<ol> <li>The user stores encrypted data in a smart contract key.</li> <li>The user defines a timeout and optional \"read before timeout\" flag.</li> <li>They assign custodians (trusted people) with roles like Reader, Writer, or Pinger.</li> <li>If the user doesn\u2019t \"ping\" within the timeout, the data becomes accessible to Readers.</li> </ol> <p>All logic is on-chain, verifiable, and enforced via Ethereum timestamps.</p>"},{"location":"business-whitepaper/#use-cases","title":"Use Cases","text":"Sector Use Case Legaltech Digital wills, estate planning Fintech Emergency key custody, account unlock triggers Enterprise Internal continuity for founder/keyholder data DAOs Governance documents unlock post-inactivity Education/IP Delayed release of confidential research"},{"location":"business-whitepaper/#why-blockchain","title":"Why Blockchain?","text":"<ul> <li>Guarantees verifiable time (via <code>block.timestamp</code>)</li> <li>Trustless role enforcement and access delegation</li> <li>No centralized custodian or backend required</li> </ul> <p>Zaphenath provides the right to remain private, until proven inactive.</p>"},{"location":"business-whitepaper/#market-strategy","title":"Market Strategy","text":"<ul> <li>Open-source core, free to use and fork</li> <li>Premium consulting for legal, enterprise, and DAO integrations</li> <li>Ecosystem grants and governance to be launched in 2026</li> </ul>"},{"location":"business-whitepaper/#team-partners","title":"Team &amp; Partners","text":"<p>Zaphenath is developed by contributors at Astervia, a research collective building decentralized infrastructure for privacy-respecting automation.</p> <ul> <li> <p>Ruy (Rfluid) Vieira \u2013 Lead Solidity Engineer   Architect of Zaphenath's smart contract infrastructure, with deep expertise in cryptographic protocols, distributed systems, and automation logic.</p> </li> <li> <p>Pedro Caninas \u2013 Head of Business Development &amp; Strategic Alliances   Leads external relations, partner ecosystems, and product-market fit strategy across legaltech, DAO tooling, and digital estate infrastructure.</p> </li> <li> <p>Jo\u00e3o Victor Zaniboni \u2013 Director of Strategy &amp; Ecosystem Growth   Drives long-term vision, funding alignment, governance modeling, and cross-sector adoption of Zaphenath across web3 and institutional platforms.</p> </li> </ul>"},{"location":"business-whitepaper/#roadmap-highlights","title":"Roadmap Highlights","text":"Milestone Date MVP &amp; Test Suite \u2705 Q2 2025 Public Docs \u2705 Q2 2025 Contract Audit Q3 2025 UI Launch Q4 2025 DAO Ecosystem Fund Q1 2026 <p>Zaphenath lets you control what happens when you can\u2019t.</p> <p>Visit zaphenath.astervia.tech or contact zaphenath@astervia.tech for collaboration, adoption, or integration inquiries.</p>"},{"location":"whitepaper/","title":"\ud83e\uddfe Zaphenath White Paper","text":"<p>A secure, time-based data release protocol powered by smart contracts.</p>"},{"location":"whitepaper/#1-introduction","title":"1. Introduction","text":"<p>Zaphenath is a smart contract protocol designed to securely store encrypted data and release it based on user-defined inactivity timeouts. Its core objective is to provide conditional data disclosure mechanisms for sensitive information such as digital wills, contingency business plans, or legal arrangements.</p> <p>The protocol enables key owners to assign access permissions to external users (\"custodians\") based on roles and ping activity. Once the defined timeout passes without a ping from the key owner or designated proxy, the encrypted data becomes accessible to specified custodians.</p> <p>Zaphenath combines smart contract automation, access control delegation, and cryptographic enforcement of inactivity conditions into a single, auditable protocol.</p>"},{"location":"whitepaper/#2-problem-motivation","title":"2. Problem &amp; Motivation","text":""},{"location":"whitepaper/#21-the-problem","title":"2.1 The Problem","text":"<p>Sensitive information, such as final wishes, internal corporate knowledge, or legal claims, often requires access only when the original holder is inactive, incapacitated, or deceased. Traditional systems lack:</p> <ul> <li>Automatic release mechanisms</li> <li>Verifiability and transparency</li> <li>Cryptographic integrity and decentralization</li> </ul>"},{"location":"whitepaper/#22-existing-solutions-fall-short","title":"2.2 Existing Solutions Fall Short","text":"<ul> <li>Centralized services: Depend on trust in institutions.</li> <li>Legal arrangements: Require physical intervention.</li> <li>Cloud storage + access sharing: Risk of early data leakage.</li> </ul> <p>There\u2019s no secure, decentralized, and programmable solution for time-gated disclosure based on user inactivity.</p>"},{"location":"whitepaper/#3-zaphenath-solution-overview","title":"3. Zaphenath Solution Overview","text":"<p>Zaphenath implements a timeout-driven key management system:</p> <ol> <li>A user creates a key, associates it with encrypted data, and configures a timeout window.</li> <li>As long as the user \"pings\" periodically, the data stays private.</li> <li>If the timeout passes with no ping, custodians with appropriate roles can access the data.</li> </ol>"},{"location":"whitepaper/#key-features","title":"Key Features","text":"<ul> <li>Per-owner key isolation</li> <li>Role-based access control: <code>Owner</code>, <code>Writer</code>, <code>Reader</code>, <code>None</code></li> <li>Per-user <code>canPing</code> flag</li> <li>Custodian delegation and revocation</li> <li>Readability toggle before timeout</li> </ul>"},{"location":"whitepaper/#innovation-highlights","title":"Innovation Highlights","text":"<ul> <li>Trustless liveness signaling without relying on external oracles</li> <li>Time-conditioned encryption with programmable release</li> <li>Modular role enforcement per key instance</li> <li>Non-custodial delegation model using self-custody-compatible logic</li> </ul>"},{"location":"whitepaper/#4-why-blockchain","title":"4. Why Blockchain?","text":""},{"location":"whitepaper/#41-trustless-timekeeping","title":"4.1 Trustless Timekeeping","text":"<p>Smart contracts ensure:</p> <ul> <li>Transparent enforcement of ping/timeout logic</li> <li>Immutability of time-based state transitions</li> </ul>"},{"location":"whitepaper/#42-decentralized-custody","title":"4.2 Decentralized Custody","text":"<p>By using Ethereum-compatible networks, Zaphenath avoids reliance on any single authority or infrastructure.</p>"},{"location":"whitepaper/#43-on-chain-access-logic","title":"4.3 On-chain Access Logic","text":"<p>Every access, update, or ping action is verified, logged, and timestamped, offering traceability and auditability.</p>"},{"location":"whitepaper/#44-compatibility-with-decentralized-storage","title":"4.4 Compatibility with Decentralized Storage","text":"<p>Zaphenath stores only encrypted pointers or data references, which can integrate seamlessly with:</p> <ul> <li>IPFS</li> <li>Arweave</li> <li>Encrypted S3 buckets</li> </ul> <p>This hybrid model enables scalable and private storage without bloating on-chain data.</p>"},{"location":"whitepaper/#5-technical-architecture","title":"5. Technical Architecture","text":""},{"location":"whitepaper/#51-core-contracts","title":"5.1 Core Contracts","text":"<ul> <li><code>Zaphenath.sol</code>: Entry point and state manager</li> <li><code>KeyData</code>: Stores encrypted content, timeout metadata, and access maps</li> <li><code>Custodian</code>: Encodes a user\u2019s role and ping rights</li> <li><code>Role</code>: Enum of access levels</li> </ul>"},{"location":"whitepaper/#52-data-flow","title":"5.2 Data Flow","text":"<pre><code>sequenceDiagram\n  participant User\n  participant Contract\n  participant Custodian\n\n  User-&gt;&gt;Contract: createKey(keyId, data, timeout)\n  loop alive\n    User-&gt;&gt;Contract: ping(keyId)\n  end\n  alt timeout expired\n    Custodian-&gt;&gt;Contract: readKey(keyId)\n  end\n</code></pre>"},{"location":"whitepaper/#53-ping-mechanism","title":"5.3 Ping Mechanism","text":"<p>Pings reset the <code>lastPing</code> timestamp. Timeout enforcement compares <code>block.timestamp - lastPing</code> against the <code>timeout</code>.</p>"},{"location":"whitepaper/#54-access-rules","title":"5.4 Access Rules","text":"<ul> <li>Roles are enforced using <code>onlyRoleOrAbove()</code></li> <li>Owner always bypasses role checks</li> <li>Custodian access requires explicit role + <code>canPing</code> (if sending ping)</li> </ul>"},{"location":"whitepaper/#55-gas-storage-considerations","title":"5.5 Gas &amp; Storage Considerations","text":"<ul> <li>Each key creates a new storage mapping under a derived <code>bytes32</code> key.</li> <li>Role and ping rights use compact structs for efficient access.</li> <li>All data is stored as opaque <code>bytes</code> allowing for encrypted payloads of any format.</li> </ul>"},{"location":"whitepaper/#6-use-cases","title":"6. Use Cases","text":"Use Case Description Digital Will Keys released to heirs after owner inactivity Business Fallbacks Keyholders can access credentials or policies upon team absence Dead Man's Switch Secrets become readable if not reset within specified interval Multi-party Disclosure Share read rights among multiple stakeholders post-timeout Posthumous DAO Voting Reveal final votes after wallet inactivity period Time-locked Research Delay release of intellectual property or publications"},{"location":"whitepaper/#7-roadmap","title":"7. Roadmap","text":"Phase Timeline Deliverables MVP \u2705 Q2 2025 Smart contract suite, tests, deploy scripts Docs &amp; Site \u2705 Q2 2025 MkDocs reference, README, changelog Audit Q3 2025 Static analysis, formal verification UI Portal Q4 2025 DApp for key creation, pinging, and read access DAO/Grants Q1 2026 Community governance &amp; integrations"},{"location":"whitepaper/#8-team","title":"8. Team","text":"<p>Zaphenath is developed by contributors at Astervia, a research collective building decentralized infrastructure for privacy-respecting automation.</p> <ul> <li> <p>Ruy (Rfluid) Vieira \u2013 Lead Solidity Engineer   Architect of Zaphenath's smart contract infrastructure, with deep expertise in cryptographic protocols, distributed systems, and automation logic.</p> </li> <li> <p>Pedro Caninas \u2013 Head of Business Development &amp; Strategic Alliances   Leads external relations, partner ecosystems, and product-market fit strategy across legaltech, DAO tooling, and digital estate infrastructure.</p> </li> <li> <p>Jo\u00e3o Victor Zaniboni \u2013 Director of Strategy &amp; Ecosystem Growth   Drives long-term vision, funding alignment, governance modeling, and cross-sector adoption of Zaphenath across web3 and institutional platforms.</p> </li> </ul>"},{"location":"whitepaper/#9-marketing-community-strategy","title":"9. Marketing &amp; Community Strategy","text":"<ul> <li>Open-source and donation-based sustainability model</li> <li>Community support via GitHub Discussions</li> <li>Long-form educational content and walkthroughs</li> <li>Targeting legaltech, DAOs, NGOs, and decentralized infrastructure builders</li> <li>Consulting packages for legal teams, death-tech startups, and custody protocols</li> </ul>"},{"location":"whitepaper/#10-safety-considerations-time-oracle-desync","title":"10. Safety Considerations: Time Oracle Desync","text":"<p>Zaphenath relies on <code>block.timestamp</code> as a time oracle to enforce timeout conditions. While this is a standard and generally reliable approach in Solidity, it is subject to miner manipulation within a limited range (~\u00b115 seconds).</p>"},{"location":"whitepaper/#potential-attack-timestamp-skewing","title":"Potential Attack: Timestamp Skewing","text":"<p>An adversarial miner or validator could attempt to advance or delay the block timestamp to:</p> <ul> <li>Trigger premature timeout (disclosing data early)</li> <li>Delay timeout enforcement (preserve secrecy longer than intended)</li> </ul>"},{"location":"whitepaper/#safety-measures","title":"Safety Measures","text":"<ul> <li>The protocol enforces reasonable timeout durations (recommended \u2265 1 day), which mitigates the impact of \u00b115s drift.</li> <li>High-resolution pings (e.g., hourly) are not recommended in high-risk use cases.</li> <li>The contract assumes honest-majority consensus in L1 or L2 block production.</li> <li>Users should avoid critical decisions based on near-expiry timeout margins.</li> </ul>"},{"location":"whitepaper/#developer-recommendations","title":"Developer Recommendations","text":"<ul> <li>Use block explorers or simulation tools to validate timeout behaviors.</li> <li>For mission-critical deployments, consider future support for cross-chain oracles (e.g., Chainlink) to confirm liveness.</li> </ul>"},{"location":"whitepaper/#11-future-directions","title":"11. Future Directions","text":""},{"location":"whitepaper/#cross-chain-interoperability","title":"Cross-Chain Interoperability","text":"<p>Zaphenath can be adapted to operate on multiple chains with standardized time signaling across rollups, sidechains, and L1s.</p>"},{"location":"whitepaper/#zero-knowledge-enhancements","title":"Zero-Knowledge Enhancements","text":"<ul> <li>zkPing proofs to allow off-chain proof of liveness without sending an on-chain transaction</li> <li>zkAccess for conditional disclosure without revealing custodian addresses</li> </ul>"},{"location":"whitepaper/#social-recovery","title":"Social Recovery","text":"<p>Planned integration with social recovery frameworks to allow delegated key reactivation via quorum-based pinging.</p>"},{"location":"whitepaper/#dao-module","title":"DAO Module","text":"<p>An optional module for DAOs to use inactivity-triggered data exposure to enforce proposals, time-locked voting, or treasury disclosures.</p>"},{"location":"whitepaper/#12-conclusion","title":"12. Conclusion","text":"<p>Zaphenath brings a novel approach to on-chain data custody. By tying access logic to ping-based activity, it creates a programmable mechanism for conditional release \u2014 ideal for high-trust, time-sensitive scenarios.</p> <p>It is:</p> <ul> <li>Minimal by design</li> <li>Secure through enforced roles</li> <li>Extensible via custom custody policies</li> </ul> <p>Join us in building verifiable trust at rest.</p>"},{"location":"contracts/custodian/","title":"Custodian Struct","text":"<p>The <code>Custodian</code> struct defines the access role and ping privileges of a user over a specific key. Each key maintains its own set of custodians in a <code>mapping(address =&gt; Custodian)</code>.</p>"},{"location":"contracts/custodian/#definition","title":"\ud83d\udcd8 Definition","text":"<pre><code>struct Custodian {\n    Role role;\n    bool canPing;\n}\n</code></pre>"},{"location":"contracts/custodian/#fields","title":"\ud83d\udd10 Fields","text":"Field Type Description <code>role</code> <code>Role</code> The role assigned to the user (None, Reader, etc.) <code>canPing</code> <code>bool</code> Whether the custodian is allowed to send <code>ping()</code>"},{"location":"contracts/custodian/#context","title":"\ud83d\udcc2 Context","text":"<p>Each <code>KeyData</code> instance includes a mapping:</p> <pre><code>mapping(address =&gt; Custodian) custodians;\n</code></pre> <p>This allows each key to define a custom access policy for multiple users.</p>"},{"location":"contracts/custodian/#use-cases","title":"\ud83d\udee0 Use Cases","text":"<ul> <li>Grant read-only access to a trusted contact after timeout.</li> <li>Allow a co-worker to refresh a ping timer on your behalf.</li> <li>Revoke permissions dynamically using <code>removeCustodian()</code>.</li> </ul>"},{"location":"contracts/custodian/#testing-tips","title":"\ud83e\uddea Testing Tips","text":"<ul> <li>Assign and read back custodian roles and ping flags</li> <li>Attempt unauthorized pings and confirm they revert</li> <li>Ensure only Owners can assign/remove custodians</li> </ul>"},{"location":"contracts/custodian/#related-functions","title":"\ud83d\udd04 Related Functions","text":"<ul> <li><code>setCustodian(...)</code></li> <li><code>removeCustodian(...)</code></li> <li><code>ping(...)</code></li> <li><code>readKey(...)</code></li> </ul> <p>\u27a1\ufe0f Next: KeyData Struct</p>"},{"location":"contracts/keydata/","title":"KeyData Struct","text":"<p>The <code>KeyData</code> struct holds the full state of a single key in the Zaphenath contract. It encapsulates all metadata and access configurations for secure storage.</p>"},{"location":"contracts/keydata/#definition","title":"\ud83d\udcd8 Definition","text":"<pre><code>struct KeyData {\n    address owner;\n    bytes data;\n    uint256 lastPing;\n    uint256 timeout;\n    bool readableBeforeTimeout;\n    mapping(address =&gt; Custodian) custodians;\n    bool exists;\n}\n</code></pre> <p>\u2139\ufe0f The <code>KeyData</code> struct uses an internal mapping, so it cannot be returned or passed directly in external/public functions.</p>"},{"location":"contracts/keydata/#fields","title":"\ud83d\udd10 Fields","text":"Field Type Description <code>owner</code> <code>address</code> Owner of the key <code>data</code> <code>bytes</code> Encrypted or opaque data payload <code>lastPing</code> <code>uint256</code> Timestamp of last <code>ping()</code> <code>timeout</code> <code>uint256</code> Number of seconds before data becomes accessible <code>readableBeforeTimeout</code> <code>bool</code> If true, allows the owner to read data before the timeout <code>custodians</code> <code>mapping(address =&gt; Custodian)</code> Role and ping permission map for external users <code>exists</code> <code>bool</code> Tracks if the key is initialized"},{"location":"contracts/keydata/#design-considerations","title":"\ud83e\udde0 Design Considerations","text":"<ul> <li>Uses nested mappings to support per-user access control.</li> <li><code>readableBeforeTimeout</code> is enforced only for the owner.</li> <li><code>exists</code> avoids accidental reads on uninitialized keys.</li> </ul>"},{"location":"contracts/keydata/#testing-tips","title":"\ud83e\uddea Testing Tips","text":"<ul> <li>Validate default values upon key creation</li> <li>Verify access rules with various custodian combinations</li> <li>Ensure timeout enforcement and <code>ping()</code> logic are working</li> </ul> <p>\u27a1\ufe0f Proceed to Using Roles and Permissions</p>"},{"location":"contracts/role/","title":"Role Enum","text":"<p>The <code>Role</code> enum defines the access level a user has to a key within the Zaphenath system. It is a critical component of the role-based access control mechanism.</p>"},{"location":"contracts/role/#definition","title":"\ud83d\udcd8 Definition","text":"<pre><code>enum Role {\n    None,\n    Reader,\n    Writer,\n    Owner\n}\n</code></pre>"},{"location":"contracts/role/#role-levels","title":"\ud83d\udd10 Role Levels","text":"<p>Each role is associated with an increasing level of access:</p> Role Value Description None 0 No access Reader 1 Can read the key (after timeout or if allowed) Writer 2 Can update and delete the key Owner 3 Full control including assigning custodians <p>Roles are evaluated using ordinal values, so <code>Role.Writer</code> is considered higher than <code>Role.Reader</code>, and so on.</p>"},{"location":"contracts/role/#usage-in-access-control","title":"\ud83d\udee1 Usage in Access Control","text":"<p>Access to sensitive operations is gated using the <code>onlyRoleOrAbove</code> modifier:</p> <pre><code>modifier onlyRoleOrAbove(bytes32 keyId, address owner, Role minimumRole) {\n    ...\n    require(uint8(callerRole) &gt;= uint8(minimumRole), \"Insufficient role\");\n    _;\n}\n</code></pre> <p>This enforces a minimum required role for specific functions.</p>"},{"location":"contracts/role/#testing-tips","title":"\ud83e\uddea Testing Tips","text":"<ul> <li>Verify downgrade (e.g. from Writer to Reader) restricts access</li> <li>Confirm escalation from None to Reader grants read access post-timeout</li> <li>Ensure Owner always bypasses role checks automatically</li> </ul> <p>\u27a1\ufe0f Continue to Custodian Struct</p>"},{"location":"contracts/zaphenath/","title":"Zaphenath Contract","text":"<p>The <code>Zaphenath</code> contract is the core of the system. It enables users to securely store and manage keys with timeout-based privacy and delegated access controls.</p>"},{"location":"contracts/zaphenath/#overview","title":"\ud83d\udcd8 Overview","text":"<p>Each key in Zaphenath is:</p> <ul> <li>Owned by a specific address</li> <li>Identified by a <code>bytes32 keyId</code></li> <li>Associated with encrypted <code>data</code></li> <li>Configured with a <code>timeout</code> and a <code>readableBeforeTimeout</code> flag</li> </ul> <p>Data becomes readable after the timeout has passed unless <code>ping()</code> is called.</p>"},{"location":"contracts/zaphenath/#key-components","title":"\ud83d\udd10 Key Components","text":""},{"location":"contracts/zaphenath/#state","title":"State","text":"<pre><code>mapping(bytes32 =&gt; KeyData) private keys;\n</code></pre> <p>Keys are internally identified by <code>keccak256(abi.encodePacked(owner, keyId))</code> to ensure per-owner uniqueness.</p>"},{"location":"contracts/zaphenath/#events","title":"Events","text":"<ul> <li><code>KeyCreated(bytes32 keyId, address owner)</code></li> <li><code>KeyDeleted(bytes32 keyId)</code></li> <li><code>KeyUpdated(bytes32 keyId)</code></li> <li><code>Pinged(bytes32 keyId, uint256 timestamp)</code></li> <li><code>CustodianUpdated(bytes32 keyId, address user, Role role, bool canPing)</code></li> </ul>"},{"location":"contracts/zaphenath/#modifiers","title":"Modifiers","text":"<ul> <li><code>onlyOwner(keyId, owner)</code></li> <li><code>onlyRoleOrAbove(keyId, owner, minimumRole)</code></li> <li><code>keyExists(keyId, owner)</code></li> </ul>"},{"location":"contracts/zaphenath/#core-functions","title":"Core Functions","text":""},{"location":"contracts/zaphenath/#createkey","title":"<code>createKey(...)</code>","text":"<p>Creates a key with an initial data payload and timeout. Only one key per <code>keyId</code> per owner.</p>"},{"location":"contracts/zaphenath/#readkey","title":"<code>readKey(...)</code>","text":"<p>Allows access based on:</p> <ul> <li>Role of the caller</li> <li>Whether timeout has expired</li> <li>If data is readable before timeout</li> </ul>"},{"location":"contracts/zaphenath/#ping","title":"<code>ping(...)</code>","text":"<p>Refreshes the last activity timestamp. Prevents timeout from triggering.</p>"},{"location":"contracts/zaphenath/#updatekey","title":"<code>updateKey(...)</code>","text":"<p>Allows Writers and Owners to update key metadata and data.</p>"},{"location":"contracts/zaphenath/#deletekey","title":"<code>deleteKey(...)</code>","text":"<p>Removes the key. Only Writer or Owner can perform this action.</p>"},{"location":"contracts/zaphenath/#setcustodian-removecustodian","title":"<code>setCustodian(...)</code> / <code>removeCustodian(...)</code>","text":"<p>Assign or revoke roles and ping permission to external addresses.</p>"},{"location":"contracts/zaphenath/#design-considerations","title":"\ud83e\udde0 Design Considerations","text":"<ul> <li><code>Custodian</code> mappings are stored within each <code>KeyData</code>, allowing per-key delegation.</li> <li>Role escalation is strictly enforced via <code>onlyRoleOrAbove()</code>.</li> <li>All key-related operations are scoped per <code>(owner, keyId)</code> pair.</li> </ul>"},{"location":"contracts/zaphenath/#recommended-tests","title":"\ud83e\uddea Recommended Tests","text":"<ul> <li>Owner creates key and reads it</li> <li>Reader cannot read before timeout</li> <li>Reader reads after timeout</li> <li>Ping resets timeout</li> <li>Custodians with and without ping permission</li> </ul> <p>\u27a1\ufe0f Learn about Role Enum</p>"},{"location":"getting-started/","title":"Overview","text":"<p>Zaphenath is a Solidity-based smart contract system for securely storing and revealing sensitive information after user inactivity. It is designed for use cases like wills, confidential business data, and contingency disclosures.</p> <p>This documentation site provides a complete guide to installing, deploying, and interacting with Zaphenath contracts, including technical specifications and code examples.</p>"},{"location":"getting-started/#key-concepts","title":"Key Concepts","text":""},{"location":"getting-started/#1-key-based-secure-storage","title":"1. Key-Based Secure Storage","text":"<p>Each key is uniquely tied to an owner and contains encrypted data and metadata, such as timeout configuration and access rules.</p>"},{"location":"getting-started/#2-ping-mechanism-for-inactivity","title":"2. Ping Mechanism for Inactivity","text":"<p>The contract uses a ping mechanism to detect user inactivity. If the user fails to send periodic \"alive\" pings, their data becomes readable by assigned custodians.</p>"},{"location":"getting-started/#3-role-based-access-control","title":"3. Role-Based Access Control","text":"<p>Zaphenath defines strict roles:</p> <ul> <li>Owner: Full permissions including management of other users.</li> <li>Writer: Can update and delete the key.</li> <li>Reader: Can read data (after timeout or if allowed earlier).</li> <li>None: No permissions.</li> </ul>"},{"location":"getting-started/#4-custodian-delegation","title":"4. Custodian Delegation","text":"<p>Users can assign custodians with specific roles and the ability to send pings on their behalf. This enables secure delegation of responsibilities.</p>"},{"location":"getting-started/#5-privacy-toggle","title":"5. Privacy Toggle","text":"<p>Data can optionally be made visible to the owner before the timeout expires using a <code>readableBeforeTimeout</code> setting.</p>"},{"location":"getting-started/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to deploy and test the Zaphenath contract</li> <li>How to create and manage keys</li> <li>How access and privacy settings work</li> <li>How to simulate inactivity and test timeout behavior</li> </ul>"},{"location":"getting-started/#who-this-is-for","title":"Who This Is For","text":"<ul> <li>Solidity developers building dApps with sensitive data handling</li> <li>Legaltech platforms handling digital wills</li> <li>Businesses needing conditional data exposure based on inactivity</li> </ul> <p>\u27a1\ufe0f Next: Installation Guide</p>"},{"location":"getting-started/deployment/","title":"Deployment","text":"<p>This guide walks you through deploying the Zaphenath contract using Foundry scripts.</p>"},{"location":"getting-started/deployment/#deploying-locally-with-anvil","title":"Deploying Locally with Anvil","text":""},{"location":"getting-started/deployment/#1-start-a-local-testnet","title":"1. Start a local testnet","text":"<pre><code>anvil\n</code></pre> <p>This launches a local Ethereum node with test accounts.</p>"},{"location":"getting-started/deployment/#2-run-the-deploy-script","title":"2. Run the deploy script","text":"<p>In a separate terminal:</p> <pre><code>forge script script/Zaphenath.s.sol \\\n  --broadcast \\\n  --rpc-url http://localhost:8545\n</code></pre> <p>You should see output showing the deployed contract address.</p>"},{"location":"getting-started/deployment/#deploying-to-a-public-testnet-eg-sepolia","title":"Deploying to a Public Testnet (e.g., Sepolia)","text":""},{"location":"getting-started/deployment/#1-set-environment-variables","title":"1. Set environment variables","text":"<p>Export your private key and RPC URL. For safety, use <code>.env</code> in real projects.</p> <pre><code>export PRIVATE_KEY=your_private_key\nexport RPC_URL=https://sepolia.infura.io/v3/YOUR_INFURA_KEY\n</code></pre>"},{"location":"getting-started/deployment/#2-deploy","title":"2. Deploy","text":"<pre><code>forge script script/Zaphenath.s.sol \\\n  --broadcast \\\n  --rpc-url $RPC_URL \\\n  --private-key $PRIVATE_KEY\n</code></pre>"},{"location":"getting-started/deployment/#deployment-output","title":"Deployment Output","text":"<p>After deployment, Foundry logs the contract address. Save it for contract interactions.</p>"},{"location":"getting-started/deployment/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Missing console logs? Ensure you're using <code>console.log</code> from <code>forge-std</code>.</li> <li>Contract not found? Verify your paths in <code>import</code> and <code>foundry.toml</code>.</li> <li>Network errors? Make sure RPC URLs and keys are correctly set.</li> </ul> <p>\u27a1\ufe0f Next: Zaphenath Contract Details</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This page guides you through setting up the Zaphenath project using the Foundry toolchain.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Git installed</li> <li>Foundry installed:</li> </ul> <pre><code>curl -L https://foundry.paradigm.xyz | bash\nfoundryup\n</code></pre> <ul> <li>A modern Solidity-compatible code editor (e.g. VS Code with Solidity plugin)</li> </ul>"},{"location":"getting-started/installation/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/Astervia/zaphenath.git\ncd zaphenath\n</code></pre>"},{"location":"getting-started/installation/#install-dependencies","title":"Install Dependencies","text":"<p>Zaphenath uses <code>forge</code> to manage dependencies.</p> <pre><code>forge install\n</code></pre> <p>If external libraries are used in the future (e.g., OpenZeppelin), you can install them via:</p> <pre><code>forge install openzeppelin/openzeppelin-contracts\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Run the tests to ensure everything is working:</p> <pre><code>forge test\n</code></pre> <p>You should see output confirming the test suite ran successfully.</p> <p>\u27a1\ufe0f Next: Deployment Guide</p>"},{"location":"reference/changelog/","title":"\ud83d\uddd2\ufe0f Changelog","text":"<p>All notable changes to Zaphenath will be documented in this file following Keep a Changelog conventions and SemVer.</p>"},{"location":"reference/changelog/#v010-20250601","title":"[v0.1.0] \u2013 2025\u201106\u201101","text":""},{"location":"reference/changelog/#added","title":"Added","text":"<ul> <li>Initial release of the full contract system.</li> <li> <p>Zaphenath.sol \u2013 Core contract for secure, timeout-gated key storage</p> </li> <li> <p>Per-owner key isolation using hashed identifiers</p> </li> <li>Role-based access control (<code>Owner</code>, <code>Writer</code>, <code>Reader</code>, <code>None</code>)</li> <li>Ping-based inactivity tracking to unlock data</li> <li>Per-key custodian delegation with <code>canPing</code> flag</li> <li> <p><code>readableBeforeTimeout</code> toggle for controlled visibility</p> </li> <li> <p>KeyData.sol \u2013 Struct for key metadata and custodian mapping</p> </li> <li>Role.sol \u2013 Enum for RBAC enforcement</li> <li> <p>Custodian.sol \u2013 Custodian role wrapper</p> </li> <li> <p>Full test suite using <code>forge-std</code></p> </li> <li> <p>Role escalation &amp; timeout logic</p> </li> <li>Ping behavior and revert expectations</li> <li> <p>Read/write/delete permission matrix</p> </li> <li> <p>Deployment script with <code>console.log</code> support</p> </li> <li>MkDocs documentation</li> <li>Full developer &amp; usage guides</li> <li>Support &amp; consulting plans</li> <li>Reference examples and lifecycle breakdown</li> </ul>"},{"location":"reference/changelog/#infrastructure","title":"Infrastructure","text":"<ul> <li>Compatible with Foundry stack (Forge, Anvil)</li> <li>Modular contract layout in <code>/src</code></li> <li>Testing in <code>/test</code>, scripts in <code>/script</code></li> <li>Docs build with <code>mkdocs-material</code></li> </ul>"},{"location":"reference/changelog/#documentation","title":"Documentation","text":"<ul> <li>Docs hosted at zaphenath.astervia.tech</li> <li>Includes lifecycle, roles, timeout explanation, and usage examples</li> <li>Consulting and donation plans available under <code>support/</code></li> </ul>"},{"location":"reference/changelog/#breaking-changes","title":"Breaking Changes","text":"<p>N/A \u2013 initial release.</p>"},{"location":"reference/changelog/#known-issues","title":"Known Issues","text":"<ul> <li>Custodian mappings are not enumerable on-chain due to Solidity limitations</li> <li>Key metadata (<code>KeyData</code>) uses internal mappings and cannot be returned directly</li> <li>Contract assumes accurate timestamp behavior (subject to miner control on public nets)</li> </ul> <p>Source available on GitHub. Contributions welcome!</p>"},{"location":"security/","title":"\ud83d\udd10 Security Overview","text":"<p>Zaphenath is designed with high-stakes scenarios in mind\u2014contexts where data should only become accessible if specific liveness signals (pings) are absent for a defined duration. This design makes the security surface both critical and nuanced.</p> <p>This section of the documentation addresses potential threats, design trade-offs, and safe deployment practices for maintaining trust in Zaphenath's conditional access guarantees.</p>"},{"location":"security/#threat-model","title":"\ud83e\udded Threat Model","text":"<p>Zaphenath assumes a semi-trusted environment with the following properties:</p> <ul> <li>Honest majority of block producers (for time-based enforcement)</li> <li>Non-malicious key owners and custodians (outside role privilege scope)</li> <li>Public chain visibility (i.e., events and storage can be monitored by anyone)</li> </ul> <p>The protocol does not rely on external oracles, off-chain cron jobs, or scheduled transactions.</p>"},{"location":"security/#key-threats-addressed","title":"\ud83e\udde8 Key Threats Addressed","text":"<ul> <li> <p>Time Oracle Manipulation   Block producers can manipulate <code>block.timestamp</code>. Zaphenath enforces safe assumptions and minimum timeout intervals to mitigate this.</p> </li> <li> <p>Privilege Escalation via Role Abuse   Improper use of <code>setCustodian()</code> could accidentally expose data. Role checks and public logs serve as verification points.</p> </li> <li> <p>Gas-Based Denial of Service (DoS)   Storage expansion, frequent pings, or malicious keys could exhaust gas. The design minimizes state complexity and avoids loops over dynamic mappings.</p> </li> <li> <p>Early Disclosure via Misconfiguration   A careless setting of <code>readableBeforeTimeout = true</code> could leak data. This flag must be carefully audited during key creation.</p> </li> </ul>"},{"location":"security/#defense-in-depth","title":"\ud83d\udd10 Defense-in-Depth","text":"Layer Mitigation Strategy Time Enforced minimum timeout, L1 time assumptions Roles Enum-based access, hard-coded privilege checks Custodians Explicit mapping per key, revocable Readability Boolean gate before timeout, enforced only for owner Ping Timestamp validation + delegation control"},{"location":"security/#developer-responsibilities","title":"\ud83d\udea7 Developer Responsibilities","text":"<p>Smart contracts cannot protect users from all misconfigurations. Developers integrating Zaphenath should:</p> <ul> <li>Validate all timeout durations are non-trivial (e.g., \u2265 1 day)</li> <li>Default to <code>readableBeforeTimeout = false</code> unless explicitly required</li> <li>Monitor on-chain events to track misuse or outdated configurations</li> <li>Write access policies and ping routines that are externally observable</li> </ul> <p>\u27a1\ufe0f Next: Time Oracle Desync Attack</p>"},{"location":"security/best-practices/","title":"\u2705 Smart Contract Best Practices","text":"<p>Zaphenath is designed with minimalism, modularity, and auditability in mind. This page outlines best practices for writing, auditing, and integrating contracts similar to Zaphenath in production environments.</p>"},{"location":"security/best-practices/#code-structure-guidelines","title":"\ud83d\udd12 Code Structure Guidelines","text":"<ul> <li>Use explicit access control \u2014 Every mutating function is guarded by <code>onlyRoleOrAbove()</code>.</li> <li>Avoid nested mappings inside structs \u2014 Keep data layout readable and storage-efficient.</li> <li>Immutable logic flow \u2014 Avoid external calls, unbounded loops, or delegatecall.</li> <li>Event coverage \u2014 Emit events on all mutating actions (create, update, delete, assign).</li> </ul>"},{"location":"security/best-practices/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":"Layer Tool Purpose Unit Tests Foundry (<code>forge</code>) Validate isolated contract behavior Integration Foundry + scripts End-to-end flow across roles and timeouts Fuzzing Foundry Randomized role/path combinations Time Simulation <code>vm.warp()</code> Timeout verification Revert Checks <code>expectRevert()</code> Ensure security fails when expected"},{"location":"security/best-practices/#suggested-coverage","title":"Suggested Coverage","text":"<ul> <li>Ping behavior &amp; logging</li> <li>Role enforcement and misassignment</li> <li>Timeout boundary enforcement</li> <li>Unauthorized access attempts</li> </ul>"},{"location":"security/best-practices/#audit-considerations","title":"\ud83d\udd0d Audit Considerations","text":"<ul> <li>Storage collisions \u2014 Ensure mappings are unique per key</li> <li>Gas analysis \u2014 Measure costs of <code>createKey</code>, <code>ping</code>, <code>readKey</code>, and <code>deleteKey</code></li> <li>Re-entrancy \u2014 Not possible here, but audit hooks before adding external integrations</li> <li>Invariant checks \u2014 For example: a Writer must not access keys unless timeout passed</li> </ul>"},{"location":"security/best-practices/#deployment-upgrade-strategy","title":"\u2699\ufe0f Deployment &amp; Upgrade Strategy","text":"<ul> <li>Immutable core \u2014 Core Zaphenath contracts are designed for permanence</li> <li>Proxy support (optional) \u2014 Wrap in upgradeable proxy pattern only if needed</li> <li>Scripted deployment \u2014 Use <code>forge script</code> to avoid manual steps</li> <li>Post-deploy tests \u2014 Immediately test timeout logic after deployment</li> </ul>"},{"location":"security/best-practices/#operational-best-practices","title":"\ud83d\udd01 Operational Best Practices","text":"<ul> <li>Monitor for excessive gas on specific keys</li> <li>Alert on <code>CustodianUpdated</code> or <code>readKey</code> usage</li> <li>Rotate test keys in staging environments</li> <li>Maintain off-chain documentation of key purposes and access levels</li> </ul> <p>\u27a1\ufe0f Next: Deploying on Private Chains</p>"},{"location":"security/dos/","title":"\u26fd Gas &amp; Denial of Service (DoS)","text":"<p>Zaphenath's contract design avoids iteration over dynamic data structures, but it's still subject to gas-related denial-of-service vectors if used carelessly or maliciously. This document explains how to avoid state bloat, excessive writes, and high-cost reads.</p>"},{"location":"security/dos/#common-dos-risks-in-solidity","title":"\ud83d\udea8 Common DoS Risks in Solidity","text":"Vector Description Storage Bloat Unbounded storage makes writes more expensive over time Looping Over Maps Not possible in Solidity; can\u2019t iterate over custodians Recursive Calls / Reentrancy Zaphenath avoids this entirely (no external contract calls) Expensive Reads Large key data or deep access nesting may exceed block gas limits Ping Flooding Repeated <code>ping()</code> calls consume storage writes &amp; log gas"},{"location":"security/dos/#zaphenath-design-decisions","title":"\u2699\ufe0f Zaphenath Design Decisions","text":""},{"location":"security/dos/#1-stateless-loops","title":"1. Stateless Loops","text":"<ul> <li>No iteration over custodians</li> <li>All access is direct via mapping lookups</li> </ul>"},{"location":"security/dos/#2-per-key-isolation","title":"2. Per-Key Isolation","text":"<ul> <li>Each key is accessed by <code>bytes32 fullKey = keccak256(owner, keyId)</code></li> <li>This minimizes shared state contention</li> </ul>"},{"location":"security/dos/#3-controlled-ping-behavior","title":"3. Controlled Ping Behavior","text":"<ul> <li><code>ping()</code> only updates a single timestamp</li> <li>Emits a log but does not mutate deep structures</li> </ul>"},{"location":"security/dos/#4-opaque-bytes-data-field","title":"4. Opaque <code>bytes</code> Data Field","text":"<ul> <li>Allows users to optimize their own data size</li> <li>Contract doesn\u2019t validate or parse the content</li> </ul>"},{"location":"security/dos/#safe-usage-guidelines","title":"\ud83d\udd12 Safe Usage Guidelines","text":"Action Recommendation Storing large payloads Keep content off-chain (e.g. IPFS), store only reference in <code>bytes</code> High-frequency pings Use rate limits via UI or scripts, no more than 1/hour recommended Deleting keys Clean up unused keys to free storage Event overuse Monitor logs if automating roles or pings"},{"location":"security/dos/#future-improvements","title":"\ud83d\udee1 Future Improvements","text":"<ul> <li>Rate-limiting for pings (optional module)</li> <li>Batch read utility (off-chain) to reduce frontend queries</li> <li>Circuit-breaker config to auto-disable misused keys</li> </ul> <p>\u27a1\ufe0f Next: Smart Contract Best Practices</p>"},{"location":"security/private-blockchain/","title":"\ud83c\udfdb Deploying Zaphenath on a Private Blockchain","text":"<p>Zaphenath is designed to be EVM-compatible and works seamlessly on private or consortium chains. This is ideal for regulated environments such as law firms, financial institutions, or corporate governance where data flow and node participation are restricted.</p>"},{"location":"security/private-blockchain/#why-use-a-private-chain","title":"\ud83e\udde9 Why Use a Private Chain?","text":"Benefit Description Controlled Participation Only approved nodes can read, write, and mine blocks Custom Gas Policies Tailor gas costs or make interactions gasless for known actors Privacy &amp; Confidentiality Operate without exposing transactions or data logs to the public internet Regulatory Alignment Match data access with internal compliance and legal processes"},{"location":"security/private-blockchain/#setup-requirements","title":"\u2699\ufe0f Setup Requirements","text":""},{"location":"security/private-blockchain/#1-choose-a-framework","title":"1. Choose a Framework","text":"<ul> <li>Geth private network (PoA or Clique)</li> <li>Besu with permissioned access</li> <li>Ganache for local testing</li> </ul>"},{"location":"security/private-blockchain/#2-adjust-genesis-file","title":"2. Adjust Genesis File","text":"<p>Set <code>chainId</code>, <code>blockTime</code>, and <code>difficulty</code> appropriately. For PoA, configure signers.</p> <pre><code>\"config\": {\n  \"chainId\": 1337,\n  \"clique\": {\n    \"period\": 5,\n    \"epoch\": 30000\n  }\n}\n</code></pre>"},{"location":"security/private-blockchain/#3-start-your-nodes","title":"3. Start Your Nodes","text":"<p>Run multiple instances to simulate consortium consensus:</p> <pre><code>geth --datadir node1 --networkid 1337 --http --http.port 8545 --nodiscover --mine --unlock \"0x...\" --password password.txt\n</code></pre>"},{"location":"security/private-blockchain/#4-deploy-zaphenath","title":"4. Deploy Zaphenath","text":"<p>Use Foundry or Hardhat to deploy the contracts:</p> <pre><code>forge script script/Zaphenath.s.sol \\\n  --rpc-url http://localhost:8545 \\\n  --broadcast --private-key $PRIVATE_KEY\n</code></pre>"},{"location":"security/private-blockchain/#customizations-for-private-chains","title":"\ud83d\udd10 Customizations for Private Chains","text":"<ul> <li>Role registry contracts to align with enterprise LDAP or user databases</li> <li>Ping automation via scheduled bots or off-chain backend integrations</li> <li>Encrypted logs or suppression of event emission for full confidentiality</li> </ul>"},{"location":"security/private-blockchain/#best-practices","title":"\ud83e\uddea Best Practices","text":"Practice Why it matters Use TLS and firewall rules Prevents external discovery or access Define onboarding/offboarding Securely manage participant key material Mirror to IPFS or Arweave Enables off-chain archival with hash consistency Run time audits internally Catch timeout misconfigurations before key creation"},{"location":"security/private-blockchain/#example-use-cases","title":"\ud83c\udf10 Example Use Cases","text":"<ul> <li>Internal HR documents that unlock after employee departure</li> <li>Legal proof-of-life systems for will verification</li> <li>Private board meeting notes with delayed access to voting blocks</li> </ul> <p>Zaphenath is EVM-neutral. If your infrastructure supports Solidity and block timestamps, it supports verifiable trust at rest.</p> <p>Need help deploying privately? Contact us.</p>"},{"location":"security/roles/","title":"\ud83d\udd10 Role Abuse &amp; Privilege Escalation","text":"<p>Role-based access control is core to Zaphenath\u2019s architecture. The <code>Role</code> enum (None, Reader, Writer, Owner) defines what each address can do for a specific key. Improper assignment or unchecked escalation can compromise the protocol\u2019s security.</p>"},{"location":"security/roles/#role-definitions","title":"\ud83d\udd01 Role Definitions","text":"Role Access Level Capabilities None 0 No access Reader 1 Can read the key after timeout Writer 2 Can update key metadata and delete the key Owner 3 Full control including assigning roles, managing custodians and reading before timeout (if enabled) <p>Each <code>KeyData</code> instance defines custodian roles using:</p> <pre><code>mapping(address =&gt; Custodian)\n</code></pre> <p>Where a <code>Custodian</code> struct contains both <code>role</code> and <code>canPing</code>.</p>"},{"location":"security/roles/#attack-vector-improper-role-assignment","title":"\ud83e\udde8 Attack Vector: Improper Role Assignment","text":""},{"location":"security/roles/#scenario","title":"Scenario","text":"<p>An owner mistakenly sets a <code>Reader</code> as a <code>Writer</code>, or enables <code>readableBeforeTimeout</code> and sets a role too high.</p>"},{"location":"security/roles/#impact","title":"Impact","text":"<ul> <li>Custodian gains ability to delete or overwrite key data.</li> <li>Confidential data becomes accessible before timeout.</li> </ul>"},{"location":"security/roles/#mitigations","title":"\ud83d\udea7 Mitigations","text":""},{"location":"security/roles/#1-explicit-role-gates","title":"1. Explicit Role Gates","text":"<p>Functions use the <code>onlyRoleOrAbove</code> modifier:</p> <pre><code>require(uint8(callerRole) &gt;= uint8(minimumRole), \"Insufficient role\");\n</code></pre> <p>This enforces strict access thresholds.</p>"},{"location":"security/roles/#2-public-events-for-role-changes","title":"2. Public Events for Role Changes","text":"<p>All custodian assignments trigger:</p> <pre><code>CustodianUpdated(keyId, user, role, canPing)\n</code></pre> <p>Allowing off-chain monitoring of escalations.</p>"},{"location":"security/roles/#3-minimal-default-permissions","title":"3. Minimal Default Permissions","text":"<p>When a key is created:</p> <ul> <li>No custodians are assigned.</li> <li>All access must be explicitly granted by the owner.</li> </ul>"},{"location":"security/roles/#best-practices","title":"\u2705 Best Practices","text":"Recommendation Reason Start with <code>Role.Reader</code> Avoid accidental write/delete privileges Use <code>canPing = false</code> unless needed Prevent unintended ping interactions Revoke roles explicitly Use <code>removeCustodian()</code> when access ends Monitor <code>CustodianUpdated</code> events Ensure no privilege creep occurs"},{"location":"security/roles/#future-improvements","title":"\ud83d\udd2d Future Improvements","text":"<ul> <li>UI-level simulation of role effects before confirmation</li> <li>Multi-sig confirmation for <code>Role.Writer</code> or <code>Owner</code> assignments</li> <li>Role expiration timestamps or time-bound roles</li> </ul> <p>\u27a1\ufe0f Next: Gas &amp; Denial of Service</p>"},{"location":"security/time-oracle/","title":"\ud83d\udd52 Time Oracle Desynchronization Attack","text":"<p>Zaphenath uses <code>block.timestamp</code> to enforce inactivity timeouts. While this is common in Solidity contracts, it introduces a subtle but important class of risk: timestamp manipulation by block producers.</p>"},{"location":"security/time-oracle/#the-risk","title":"\u26a0\ufe0f The Risk","text":"<p>Validators or miners may slightly adjust <code>block.timestamp</code> within a protocol-defined drift range (typically \u00b115 seconds). This means:</p> <ul> <li>A malicious validator could slightly accelerate block time to trigger a timeout earlier than expected.</li> <li>Or they could delay timeout execution, giving a custodian less time to read the key.</li> </ul> <p>While these shifts are small, their impact scales with:</p> <ul> <li>Short timeout configurations (e.g., under 1 hour)</li> <li>Misconfigured <code>readableBeforeTimeout</code> access rules</li> </ul>"},{"location":"security/time-oracle/#mitigations-in-zaphenath","title":"\ud83d\udd12 Mitigations in Zaphenath","text":""},{"location":"security/time-oracle/#1-enforced-timeout-thresholds","title":"1. Enforced Timeout Thresholds","text":"<p>Users are expected to set timeouts of at least 1 day, making manipulation by \u00b115s negligible.</p>"},{"location":"security/time-oracle/#2-ping-enforcement","title":"2. Ping Enforcement","text":"<p>Pings reset the timeout timer and are logged on-chain, providing evidence of liveness.</p>"},{"location":"security/time-oracle/#3-no-timestamp-comparisons-between-blocks","title":"3. No Timestamp Comparisons Between Blocks","text":"<p>The contract only compares <code>block.timestamp</code> against <code>lastPing</code>, avoiding logic that relies on absolute time ranges.</p>"},{"location":"security/time-oracle/#4-no-scheduled-callbacks-or-automation","title":"4. No Scheduled Callbacks or Automation","text":"<p>Zaphenath doesn\u2019t use cron-like scheduling. Every action is explicitly triggered by user or custodian calls, reducing timing dependencies.</p>"},{"location":"security/time-oracle/#safe-usage-guidelines","title":"\u2705 Safe Usage Guidelines","text":"Situation Recommendation Timeout &lt; 1 hour Not recommended Timeout \u2265 1 day Safe for most use cases Critical secrets (e.g. wills) Use 7\u201330 days timeout with custodial pings Time-sensitive access Monitor blockchain time closely"},{"location":"security/time-oracle/#suggested-enhancements-future-work","title":"\ud83d\udee0 Suggested Enhancements (Future Work)","text":"<ul> <li>Layer-2 timestamp validation: Accept only L1 timestamps in rollup contexts.</li> <li>Cross-chain oracle integration: To validate that a ping came after a real-world time threshold.</li> <li>zkPing: Off-chain proofs of liveness, verified on-chain without <code>block.timestamp</code>.</li> </ul> <p>\u27a1\ufe0f Next: Role Abuse &amp; Privilege Escalation</p>"},{"location":"support/consulting/","title":"\ud83d\udee0\ufe0f Zaphenath Consulting Services","text":"<p>We don't license Zaphenath \u2014 we empower you to adapt and scale it. Donations fund our time to help you customize the system to your infrastructure, regulatory needs, and product goals.</p>"},{"location":"support/consulting/#who-is-this-for","title":"\ud83d\udc65 Who is this for?","text":"You are... You need... A legaltech startup On-chain will management, smart contract support A blockchain consultant Timeout-based privacy contracts for client projects A regulated enterprise Auditable access flows, custom custody features, compliance help A DAO or NGO Community-based access models, multisig delegation, secure infra"},{"location":"support/consulting/#what-we-offer","title":"\ud83d\udd27 What we offer","text":""},{"location":"support/consulting/#security-smart-contract-review","title":"\ud83d\udd10 Security &amp; Smart Contract Review","text":"<ul> <li>Custom timeout models and multisig fallback logic</li> <li>Solidity refactoring and upgrades</li> <li>Role escalation audit trails, access recovery mechanisms</li> </ul>"},{"location":"support/consulting/#infrastructure-deployment","title":"\ud83e\uddf1 Infrastructure &amp; Deployment","text":"<ul> <li>Testnet/mainnet pipelines with Foundry and GitHub Actions</li> <li>Custom RPC/network support</li> <li>Secure hosting (IPFS, S3, hybrid)</li> </ul>"},{"location":"support/consulting/#feature-extensions","title":"\ud83e\udde9 Feature Extensions","text":"<ul> <li>ABI-safe hooks and contract events</li> <li>Third-party notarization and timestamping adapters</li> <li>Integration with L2 rollups or multisig wallets</li> </ul>"},{"location":"support/consulting/#onboarding-documentation","title":"\ud83c\udf93 Onboarding &amp; Documentation","text":"<ul> <li>Team workshops (30\u201390 min)</li> <li>Operator handoff playbooks</li> <li>Support channels (Slack, email)</li> </ul>"},{"location":"support/consulting/#engagement-models","title":"\ud83d\udca1 Engagement Models","text":"Tier Donation (USD) Includes Vault \u2265 $200 Up to 4h consulting + Git access to internal forks Sprint Quote Fixed-scope feature (e.g., recovery module, new role logic) Retainer From $300/mo SLA-based support, architecture reviews, roadmap sync <p>All work is delivered under MIT or your preferred OSS license. We collaborate via GitHub, GitLab, or self-hosted platforms.</p>"},{"location":"support/consulting/#how-to-get-started","title":"\ud83d\udcac How to get started","text":"<ol> <li> <p>Email zaphenath@astervia.tech with:</p> </li> <li> <p>A description of your use case</p> </li> <li>Your current stack and desired outcomes</li> <li> <p>Budget/timeline constraints</p> </li> <li> <p>We\u2019ll schedule a free 30-minute discovery call</p> </li> <li>You\u2019ll receive a Statement of Work (SoW) and donation tier suggestion</li> <li>Once donated, we onboard you and begin work</li> </ol> <p>Need a mutual NDA? Send your template, we\u2019ll sign digitally.</p>"},{"location":"support/consulting/#why-donation-based","title":"\ud83e\udd1d Why donation-based?","text":"<ul> <li>Keeps Zaphenath open-source and license-free</li> <li>Avoids vendor lock-in or platform tax</li> <li>Aligns incentives between core devs and user success</li> </ul> <p>\ud83d\udce9 Let\u2019s build trust-minimized systems together: zaphenath@astervia.tech</p>"},{"location":"support/faq/","title":"\u2753 Frequently Asked Questions (FAQ)","text":""},{"location":"support/faq/#what-is-zaphenath","title":"\ud83e\udde9 What is Zaphenath?","text":"<p>Zaphenath is a smart contract system that locks data until a user becomes inactive. It\u2019s designed for wills, fail-safes, and privacy-bound disclosures.</p>"},{"location":"support/faq/#do-i-need-to-use-a-frontend","title":"\ud83d\udee0 Do I need to use a frontend?","text":"<p>No, you can interact directly using Foundry, Ethers.js, or other on-chain tools. However, a frontend improves usability for non-technical users.</p>"},{"location":"support/faq/#how-does-the-timeout-system-work","title":"\u23f3 How does the timeout system work?","text":"<p>Each key has a <code>lastPing</code> and <code>timeout</code>. If <code>block.timestamp - lastPing &gt; timeout</code>, data becomes readable to authorized users.</p>"},{"location":"support/faq/#can-i-test-locally","title":"\ud83e\uddea Can I test locally?","text":"<p>Yes! Use Anvil to simulate a testnet and <code>forge test</code> to run unit tests. See the Testing Overview for details.</p>"},{"location":"support/faq/#can-custodians-be-changed","title":"\ud83d\udd01 Can custodians be changed?","text":"<p>Yes, owners can add, update, or remove custodians dynamically using <code>setCustodian()</code> and <code>removeCustodian()</code>.</p>"},{"location":"support/faq/#who-can-read-the-data","title":"\ud83d\udd10 Who can read the data?","text":"<p>Only the owner (before timeout, if allowed) and authorized custodians (after timeout) with <code>Reader</code> or <code>Writer</code> roles.</p>"},{"location":"support/faq/#is-this-production-ready","title":"\ud83e\uddd1\u200d\ud83d\udcbb Is this production-ready?","text":"<p>The code is well-tested but should be audited before mainnet use in high-stakes environments. We offer consulting for integration and audit prep.</p>"},{"location":"support/faq/#how-do-i-support-the-project","title":"\ud83d\udcb8 How do I support the project?","text":"<p>Check the Support Plans and consider donating via Bitcoin or Lightning. All funds help sustain open-source development.</p>"},{"location":"support/faq/#how-do-i-get-in-touch","title":"\ud83d\udcec How do I get in touch?","text":"<p>Email zaphenath@astervia.tech \u2014 whether it\u2019s a bug report, partnership idea, or consulting request, we\u2019re here to help.</p>"},{"location":"support/plans/","title":"\ud83d\udc8e Support Plans for Zaphenath","text":"<p>Zaphenath is open-source infrastructure for time-gated access control. We don\u2019t sell software \u2014 we develop it collaboratively. Your donation keeps updates coming, tests running, and features evolving. In exchange, we unlock tools and consultancy time based on your support tier.</p> <p>You may also donate outside of fixed plans and still receive thanks and community recognition.</p> Plan Donation (USD) What you unlock Ideal For Seed 10 \u2192 99 USD(\u2248 0.00010 \u2192 0.00099 BTC) \u2022 Community access\u2022 Acknowledgment in CONTRIBUTORS.md Students, small teams, open-source supporters Covenant 100 \u2192 199 USD(\u2248 0.001 \u2192 0.00199 BTC) Everything in Seed plus:\u2022 Docker test environment\u2022 Smart contract review session (30 min)\u2022 Feature request priority dApp builders, blockchain researchers Vault \u2265\u202f200 USD(\u2265 0.002 BTC) Everything in Covenant plus:\u2022 Up to 4h technical consulting (security audit, integration help)\u2022 GitHub repo access to custom forks\u2022 Branding &amp; feature toggles Enterprises, legaltech platforms, on-prem adopters <p>Vault is custom-scoped. Email zaphenath@astervia.tech to start the conversation and get a tailored Statement of Work.</p>"},{"location":"support/plans/#how-to-donate","title":"\ud83d\udcb8 How to Donate","text":""},{"location":"support/plans/#bitcoin-on-chain","title":"Bitcoin (on-chain)","text":"<pre><code>bc1qh0tl3tn9xum66htma92lypj7s6ryr6uymut9sh\n</code></pre>"},{"location":"support/plans/#lightning-instant","title":"Lightning (\u26a1 instant)","text":"<pre><code>evilpantry77@walletofsatoshi.com\n</code></pre> <p>We use the Coinbase BTC-USD daily rate to map donation values.</p>"},{"location":"support/plans/#after-you-donate","title":"After You Donate","text":"<ol> <li>Forward the transaction ID or screenshot to zaphenath@astervia.tech</li> <li>You\u2019ll receive access credentials, bonus files, and a calendar link (if applicable) within 48 hours</li> </ol> <p>Thank you for supporting long-term decentralization.</p>"},{"location":"testing/overview/","title":"Testing Overview","text":"<p>Zaphenath includes a full suite of tests written with the Foundry framework (<code>forge-std</code>). These tests ensure the core behaviors of the system are enforced reliably across key lifecycle operations, access control, and timeout logic.</p>"},{"location":"testing/overview/#test-file","title":"\u2705 Test File","text":"<ul> <li><code>test/Zaphenath.t.sol</code></li> </ul> <p>This file contains unit tests for:</p> <ul> <li>Key creation and uniqueness</li> <li>Ping mechanics</li> <li>Read conditions before and after timeout</li> <li>Custodian assignments and role enforcement</li> <li>Key updates and deletions</li> </ul>"},{"location":"testing/overview/#how-to-run-tests","title":"\ud83d\udd27 How to Run Tests","text":"<pre><code>forge test -vv\n</code></pre> <ul> <li><code>-vv</code> enables verbose output including <code>console.log</code> traces.</li> <li>All tests are self-contained and simulate user addresses using <code>vm.prank()</code>.</li> </ul>"},{"location":"testing/overview/#example-assertion","title":"\ud83d\udd0d Example Assertion","text":"<pre><code>assertEq(data, bytes(\"Soli Deo Gloria\"));\n</code></pre> <p>Used to verify key content and state mutations.</p>"},{"location":"testing/overview/#test-helpers","title":"\ud83e\uddea Test Helpers","text":"<ul> <li><code>vm.warp()</code> to simulate time passing</li> <li><code>vm.expectRevert()</code> to test failure conditions</li> <li><code>vm.prank(address)</code> to impersonate users</li> </ul>"},{"location":"testing/overview/#suggested-additions","title":"\ud83d\udd01 Suggested Additions","text":"<ul> <li>Fuzz tests for timeout edge cases</li> <li>Property tests for role escalations and demotions</li> <li>Integration tests across multiple keys and users</li> </ul> <p>\u27a1\ufe0f Learn about Writing Custom Tests</p>"},{"location":"testing/writing-tests/","title":"Writing Custom Tests","text":"<p>This guide helps you write additional tests for the Zaphenath contract using the Foundry testing framework.</p>"},{"location":"testing/writing-tests/#setup","title":"\ud83e\uddf0 Setup","text":"<p>Tests are located in the <code>test/</code> directory and follow this structure:</p> <pre><code>contract ZaphenathTest is Test {\n    Zaphenath public zaph;\n\n    function setUp() public {\n        zaph = new Zaphenath();\n    }\n}\n</code></pre> <p>Use <code>vm.prank()</code> to simulate calls from different addresses:</p> <pre><code>vm.prank(rachel);\nzaph.createKey(...);\n</code></pre>"},{"location":"testing/writing-tests/#common-tools","title":"\u2705 Common Tools","text":"Tool Description <code>vm.prank()</code> Simulate msg.sender <code>vm.warp()</code> Simulate time passing <code>vm.expectRevert()</code> Expect failure with specific reason <code>console.log()</code> Debug inside tests"},{"location":"testing/writing-tests/#test-ideas","title":"\ud83e\uddea Test Ideas","text":"<ul> <li>\ud83d\udce4 A Writer tries to delete a key</li> <li>\ud83d\udd10 A Reader tries to update a key (should fail)</li> <li>\u23f1 A custodian pings just before timeout</li> <li>\ud83d\udeab Unauthorized user tries to assign custodian</li> </ul>"},{"location":"testing/writing-tests/#example-prevent-non-owner-ping-without-permission","title":"\ud83e\udde9 Example: Prevent Non-Owner Ping Without Permission","text":"<pre><code>function testCustodianCannotPingIfNotAllowed() public {\n    vm.prank(owner);\n    zaph.setCustodian(keyId, owner, jacob, Role.Writer, false);\n\n    vm.prank(jacob);\n    vm.expectRevert(\"Not authorized to ping\");\n    zaph.ping(keyId, owner);\n}\n</code></pre> <p>\ud83e\uddea Don\u2019t forget to run your tests with:</p> <pre><code>forge test -vv\n</code></pre> <p>\u27a1\ufe0f Visit the Support FAQ</p>"},{"location":"usage/examples/","title":"Usage Examples","text":"<p>This page provides practical examples for using the Zaphenath contract in real scenarios, focusing on core operations such as key creation, access control, and timeout behavior.</p>"},{"location":"usage/examples/#create-a-key","title":"\ud83e\uddea Create a Key","text":"<pre><code>vm.prank(rachel);\nzaph.createKey(\"0xabc123\", bytes(\"Top Secret\"), 3 days, true);\n</code></pre> <p>Rachel creates a key that will become public in 3 days unless she pings.</p>"},{"location":"usage/examples/#owner-reads-before-timeout","title":"\ud83d\udc41 Owner Reads Before Timeout","text":"<pre><code>vm.prank(rachel);\nbytes memory data = zaph.readKey(\"0xabc123\", rachel);\n</code></pre> <p>Since <code>readableBeforeTimeout = true</code>, Rachel can read it before timeout.</p>"},{"location":"usage/examples/#reader-cant-read-before-timeout","title":"\ud83d\udd12 Reader Can't Read Before Timeout","text":"<pre><code>vm.prank(rachel);\nzaph.setCustodian(\"0xabc123\", rachel, jacob, Role.Reader, false);\n\nvm.prank(jacob);\nvm.expectRevert(\"Insufficient role\");\nzaph.readKey(\"0xabc123\", rachel);\n</code></pre> <p>Jacob is a Reader, but can't read before the timeout expires.</p>"},{"location":"usage/examples/#read-after-timeout","title":"\u231b Read After Timeout","text":"<pre><code>vm.warp(block.timestamp + 4 days);\n\nvm.prank(jacob);\nbytes memory data = zaph.readKey(\"0xabc123\", rachel);\n</code></pre> <p>After the timeout, Jacob can read the key.</p>"},{"location":"usage/examples/#custodian-pings","title":"\ud83d\udd01 Custodian Pings","text":"<pre><code>vm.prank(rachel);\nzaph.setCustodian(\"0xabc123\", rachel, jacob, Role.Writer, true);\n\nvm.prank(jacob);\nzaph.ping(\"0xabc123\", rachel);\n</code></pre> <p>Jacob keeps the data private by resetting the timeout.</p>"},{"location":"usage/examples/#delete-key","title":"\ud83d\uddd1 Delete Key","text":"<pre><code>vm.prank(rachel);\nzaph.deleteKey(\"0xabc123\", rachel);\n</code></pre> <p>Key is removed permanently.</p> <p>\u27a1\ufe0f Next: Test Coverage</p>"},{"location":"usage/key-lifecycle/","title":"Key Lifecycle","text":"<p>This guide outlines the full lifecycle of a key in the Zaphenath system\u2014from creation to deletion, including access control and timeout transitions.</p>"},{"location":"usage/key-lifecycle/#1-key-creation","title":"\ud83e\udeaa 1. Key Creation","text":"<p>Keys are created using <code>createKey()</code> by the owner.</p> <pre><code>zaph.createKey(keyId, data, timeout, readableBeforeTimeout);\n</code></pre> <ul> <li><code>keyId</code>: A unique identifier per owner (hashed internally)</li> <li><code>data</code>: Encrypted or confidential content</li> <li><code>timeout</code>: Seconds until public access if no ping</li> <li><code>readableBeforeTimeout</code>: If true, owner can read anytime</li> </ul>"},{"location":"usage/key-lifecycle/#2-key-access","title":"\ud83d\udc41 2. Key Access","text":"<p>Reading a key requires:</p> <ul> <li>Caller to be <code>Reader</code>, <code>Writer</code>, or <code>Owner</code></li> <li>Timeout to have passed, unless:</li> <li>Caller is the owner and <code>readableBeforeTimeout</code> is true</li> </ul> <pre><code>zaph.readKey(keyId, owner);\n</code></pre>"},{"location":"usage/key-lifecycle/#3-maintaining-privacy-ping","title":"\ud83d\udd01 3. Maintaining Privacy (Ping)","text":"<p>The owner or a custodian (if allowed) must call <code>ping()</code> periodically to reset the <code>lastPing</code> timestamp:</p> <pre><code>zaph.ping(keyId, owner);\n</code></pre> <p>Failing to ping will result in data becoming readable after the timeout period.</p>"},{"location":"usage/key-lifecycle/#4-managing-custodians","title":"\ud83e\uddd1\u200d\ud83e\udd1d\u200d\ud83e\uddd1 4. Managing Custodians","text":"<p>The owner can assign or remove custodians:</p> <pre><code>zaph.setCustodian(keyId, owner, user, Role.Writer, true);\nzaph.removeCustodian(keyId, owner, user);\n</code></pre>"},{"location":"usage/key-lifecycle/#5-updating-keys","title":"\u270f\ufe0f 5. Updating Keys","text":"<p>Users with <code>Writer</code> or <code>Owner</code> roles can update:</p> <pre><code>zaph.updateKey(keyId, owner, newData, newTimeout, newReadableFlag);\n</code></pre>"},{"location":"usage/key-lifecycle/#6-deleting-keys","title":"\ud83d\uddd1 6. Deleting Keys","text":"<p>Writers and Owners can delete the key permanently:</p> <pre><code>zaph.deleteKey(keyId, owner);\n</code></pre>"},{"location":"usage/key-lifecycle/#7-access-reverts-to-public-post-timeout","title":"\ud83d\udd12 7. Access Reverts to Public (Post-Timeout)","text":"<p>Once timeout expires and no ping has occurred, any custodian with <code>Reader</code> or higher access can read the key.</p> <p>\u27a1\ufe0f See Examples for practical workflows</p>"},{"location":"usage/ping/","title":"Ping Mechanism","text":"<p>The <code>ping()</code> function is a core feature of the Zaphenath contract. It keeps data private by updating the <code>lastPing</code> timestamp and thereby delaying the timeout.</p>"},{"location":"usage/ping/#purpose","title":"\ud83e\udded Purpose","text":"<p>Zaphenath allows data to be accessed only after the owner has been inactive for a certain period. This inactivity is measured as:</p> <pre><code>block.timestamp - lastPing &gt; timeout\n</code></pre> <p>By calling <code>ping()</code>, the owner or an authorized custodian can reset this timer.</p>"},{"location":"usage/ping/#function-signature","title":"\ud83d\udd01 Function Signature","text":"<pre><code>function ping(bytes32 keyId, address owner) external;\n</code></pre>"},{"location":"usage/ping/#who-can-ping","title":"\u2705 Who Can Ping?","text":"<ul> <li>Owner: Always allowed</li> <li>Custodians: Only if <code>canPing</code> was set to <code>true</code> by the owner</li> </ul>"},{"location":"usage/ping/#use-cases","title":"\ud83d\udee0 Use Cases","text":"<ul> <li>Keep private data hidden as long as the user is \"active\"</li> <li>Allow a trusted custodian to maintain activity on behalf of a user</li> <li>Ensure data is only released if truly inactive or incapacitated</li> </ul>"},{"location":"usage/ping/#behavior","title":"\u26a0\ufe0f Behavior","text":"<ul> <li>If a user fails to call <code>ping()</code> and <code>timeout</code> expires, data becomes readable by Readers and Writers</li> <li>Repeated <code>ping()</code> calls extend the private window indefinitely</li> </ul>"},{"location":"usage/ping/#testing-scenarios","title":"\ud83e\uddea Testing Scenarios","text":"<ul> <li>Owner calls <code>ping()</code> \u2192 should update <code>lastPing</code></li> <li>Custodian without ping permission \u2192 call reverts</li> <li>Custodian with ping permission \u2192 call succeeds</li> <li>No <code>ping()</code> and time advances \u2192 <code>readKey()</code> becomes accessible</li> </ul> <p>\u27a1\ufe0f Continue to Key Lifecycle</p>"},{"location":"usage/roles/","title":"Roles and Permissions","text":"<p>Zaphenath uses a role-based access control system to manage interactions with keys. Each role defines the permissions a user has on a specific key, and these roles are enforced per <code>(keyId, owner)</code>.</p>"},{"location":"usage/roles/#roles","title":"\ud83d\udd11 Roles","text":"Role Access Level Capabilities None 0 No access Reader 1 Can read the key after timeout Writer 2 Can update key metadata and delete the key Owner 3 Full control including assigning roles, managing custodians and reading before timeout (if enabled)"},{"location":"usage/roles/#custodians","title":"\ud83d\udc65 Custodians","text":"<p>Custodians are external addresses assigned a role and optional ping permission by the key owner.</p> <pre><code>setCustodian(keyId, owner, user, Role.Writer, true);\n</code></pre> <p>This allows for:</p> <ul> <li>Delegated Reading: Readers can view key data after timeout</li> <li>Collaborative Editing: Writers can update/delete the key</li> <li>Inactivity Protection: Custodians with <code>canPing = true</code> can maintain the key\u2019s private state</li> </ul>"},{"location":"usage/roles/#role-checks-in-practice","title":"\u2699\ufe0f Role Checks in Practice","text":"<p>Every function in the contract uses <code>onlyRoleOrAbove</code> to ensure the caller has sufficient privilege:</p> <pre><code>require(uint8(callerRole) &gt;= uint8(minimumRole), \"Insufficient role\");\n</code></pre> <p>The owner always bypasses role checks and is considered highest priority.</p>"},{"location":"usage/roles/#testing-scenarios","title":"\ud83e\uddea Testing Scenarios","text":"<ul> <li>Assign Jacob as Reader \u2192 he should read only after timeout</li> <li>Promote to Writer \u2192 he can now update/delete</li> <li>Demote to None \u2192 he loses all access</li> <li>Add ping permission \u2192 he can extend key privacy</li> </ul> <p>\u27a1\ufe0f Learn about the Ping Mechanism</p>"}]}